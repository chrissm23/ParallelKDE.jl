<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ParallelKDE.jl</title><meta name="title" content="Home · ParallelKDE.jl"/><meta property="og:title" content="Home · ParallelKDE.jl"/><meta property="twitter:title" content="Home · ParallelKDE.jl"/><meta name="description" content="Documentation for ParallelKDE.jl."/><meta property="og:description" content="Documentation for ParallelKDE.jl."/><meta property="twitter:description" content="Documentation for ParallelKDE.jl."/><meta property="og:url" content="https://chrissm23.github.io/ParallelKDE.jl/"/><meta property="twitter:url" content="https://chrissm23.github.io/ParallelKDE.jl/"/><link rel="canonical" href="https://chrissm23.github.io/ParallelKDE.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="ParallelKDE.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>ParallelKDE.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Basic-Example"><span>Basic Example</span></a></li><li><a class="tocitem" href="#Density-Estimation-for-Conformational-Samples"><span>Density Estimation for Conformational Samples</span></a></li><li><a class="tocitem" href="#GradePro-vs-Rules-of-Thumb"><span>GradePro vs Rules of Thumb</span></a></li><li><a class="tocitem" href="#Usage-Summary"><span>Usage Summary</span></a></li></ul></li><li><a class="tocitem" href="installation/">Installation</a></li><li><span class="tocitem">Estimators</span><ul><li><a class="tocitem" href="estimators/gradepro/">GradePro Estimator</a></li><li><a class="tocitem" href="estimators/rot/">Rules of Thumb Estimator</a></li></ul></li><li><a class="tocitem" href="contributing/">Contributing and Support</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="api_reference/devices/">Devices Interface</a></li><li><a class="tocitem" href="api_reference/grids/">Grids Interface</a></li><li><a class="tocitem" href="api_reference/kdes/">KDE Interface</a></li><li><a class="tocitem" href="api_reference/estimators/">Estimators Interface</a></li><li><a class="tocitem" href="api_reference/parallel_kde/">ParallelKDE Interface</a></li><li><a class="tocitem" href="api_reference/direct_space/">Direct Space Interface</a></li><li><a class="tocitem" href="api_reference/fourier_space/">Fourier Space Interface</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ParallelKDE"><a class="docs-heading-anchor" href="#ParallelKDE">ParallelKDE</a><a id="ParallelKDE-1"></a><a class="docs-heading-anchor-permalink" href="#ParallelKDE" title="Permalink"></a></h1><p><a href="https://github.com/chrissm23/ParallelKDE.jl">ParallelKDE</a> is a package for flexible and efficient kernel density estimation (KDE), with a strong focus on parallel implementations. Its core estimator, the <a href="estimators/gradepro/#GradeproEstimator">GradePro Estimator</a> described here, supports CPU and GPU acceleration (threaded and CUDA), and its designed to scale with modern hardware. While the package is centered around grid-based KDEs, it also provides extensible infrastructure to support and implement other types of estimators.</p><p>The user interface is built around a modular design that separates concerns between grids, devices, density objects and estimation routines. This allows users to easily switch estimators, control execution targets (e.g., CPU or GPU), and prototype new estimation strategies without rewriting boilerplate code.</p><p>Typical usage involves:</p><ul><li>Instantiating an estimation in a specific device (e.g., CPU, CUDA),</li><li>This also involves defining a grid for the estimation or using a default grid,</li><li>Estimating the density with a chosen estimator,</li><li>Accessing the resulting density.</li></ul><h2 id="Basic-Example"><a class="docs-heading-anchor" href="#Basic-Example">Basic Example</a><a id="Basic-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Example" title="Permalink"></a></h2><p>For example, to estimate a density on a CPU with a default grid using the <a href="estimators/gradepro/#GradeproEstimator">GradePro Estimator</a>, you can use:</p><pre><code class="language-julia hljs">using ParallelKDE

data = randn(1, 10000) # 1-dimensional sample of 10000 points

density_estimation = initialize_estimation(
  data,
  grid=true, # default grid
  device=:cpu,
)
estimate_density!(
  density_estimation,
  :gradepro,
)

density_estimated = get_density(density_estimation)</code></pre><p>We can evaluate the standard normal distribution for comparison:</p><pre><code class="language-julia hljs">using Distributions

grid_coordinates = get_coordinates(get_grid(density_estimation))[1, :]
density_true = pdf.(Normal(), grid_coordinates)</code></pre><p>which would yield a plot like this:</p><pre><code class="language-julia hljs">using Plots

p = plot(grid_coordinates, density_true, label=&quot;True Density&quot;, color=:cornflowerblue, lw=2)
plot!(p, grid_coordinates, density_estimated, label=&quot;Estimated Density&quot;, color=:firebrick, lw=2)
plot!(p, xlabel=&quot;Random Variable&quot;, ylabel=&quot;Density&quot;)</code></pre><p><img src="basic_usage.svg" alt/></p><h2 id="Density-Estimation-for-Conformational-Samples"><a class="docs-heading-anchor" href="#Density-Estimation-for-Conformational-Samples">Density Estimation for Conformational Samples</a><a id="Density-Estimation-for-Conformational-Samples-1"></a><a class="docs-heading-anchor-permalink" href="#Density-Estimation-for-Conformational-Samples" title="Permalink"></a></h2><p>Here, we exemplify the use of <code>ParallelKDE</code> to estimate the conformational density of alanine dipeptide via dihedral angles.</p><p>We start by downloading and reading the dataset of dihedral angles obtained from molecular dynamics trajectories <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1" class="footnote-ref">[1]</a><span class="footnote-preview" id="fn-1"></span></sup> <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2" class="footnote-ref">[2]</a><span class="footnote-preview" id="fn-2"></span></sup>.</p><pre><code class="language-julia hljs">using Downloads
using NPZ

url = &quot;http://ftp.imp.fu-berlin.de/pub/cmb-data/alanine-dipeptide-3x250ns-backbone-dihedrals.npz&quot;
dest = joinpath(pwd(), &quot;ala_dipeptide_dihderals.npz&quot;)
Downloads.download(url, dest)

ala_npz = npzread(dest)
ala = vcat(values(ala_npz)...)
# afterwards one may need to subsample the dataset to obtain uncorrelated samples.</code></pre><p>This time around we will define the grid that we want to use for the estimation instead of using the default grid:</p><pre><code class="language-julia hljs">using ParallelKDE

phi_range, psi_range = fill(range(-π, π, length=250), 2)
dihedral_grid = initialize_grid([phi_range, psi_range], device=:cpu) # or device=:cuda

density_estimation = initialize_estimation(
  ala&#39;, grid=dihedral_grid, device=:cpu # or device=:cuda
)
estimate_density!(density_estimation, :gradepro)
estimated_density = get_density(density_estimation)</code></pre><p>Finally, we can create a contour plot of the estimated density:</p><pre><code class="language-julia hljs">using Plots
using LaTeXStrings

p = contourf(phi_range, psi_range, estimated_density&#39;)
plot!(p, xlabel=L&quot;$\phi$&quot;, ylabel=L&quot;$\psi$&quot;, colorbar_title=&quot;Estimated Density&quot;)</code></pre><p><img src="ala_dihedrals.svg" alt/></p><h2 id="GradePro-vs-Rules-of-Thumb"><a class="docs-heading-anchor" href="#GradePro-vs-Rules-of-Thumb">GradePro vs Rules of Thumb</a><a id="GradePro-vs-Rules-of-Thumb-1"></a><a class="docs-heading-anchor-permalink" href="#GradePro-vs-Rules-of-Thumb" title="Permalink"></a></h2><p><code>ParallelKDE</code> also provides a <a href="estimators/rot/#RotEstimator">Rules of Thumb Estimator</a> for bandwidth selection based on widely used rule-of-thumb heuristics. As with the <a href="estimators/gradepro/#GradeproEstimator">GradePro Estimator</a>, this estimator is available in both serial and CUDA variants. In practice, the Rules of Thumb approach can be extremely fast and yields competitive accuracy when the sample distribution is close to Gaussian; however, its performance can degrade rapidly as the underlying distribution departs from Gaussianity. Now, we illustrate this trade-off by comparing results produced by both estimators on samples drawn from a bimodal distribution.</p><p>We first initialize the distribution and obtain samples from it:</p><pre><code class="language-julia hljs">using Distributions

distro = MixtureModel(
  Normal[
    Normal(-6.0, 0.2),
    Normal(0.0, 2),
  ]
)
samples = rand(distro, 1, 10000) # 1-dimensional sample of 10000 points</code></pre><p>We can again initialize a grid and the estimations for both methods with:</p><pre><code class="language-julia hljs">using ParallelKDE

xs = range(-10, 10, length=250)

grid_bimodal = initialize_grid([xs], device=:cpu) # or device=:cuda

estimation_gradepro = initialize_estimation(
  samples, grid=grid_bimodal, device=:cpu # or device=:cuda
)
estimation_rot = initialize_estimation(
  samples, grid=grid_bimodal, device=:cpu # or device=:cuda
)</code></pre><p>Now we can execute both estimations and calculate the true density with:</p><pre><code class="language-julia hljs">estimate_density!(estimation_gradepro, :gradepro)
density_gradepro = get_density(estimation_gradepro)

estimate_density!(estimation_rot, :rot)
density_rot = get_density(estimation_rot)

density_true = pdf.(distro, xs)</code></pre><p>Finally, we can visualize the results with:</p><pre><code class="language-julia hljs">using Plots

p = plot(xs, density_true, lw=3, ls=:dash, label=&quot;True Distribution&quot;)
plot!(p, xs, density_gradepro, lw=2, label=&quot;GradePro Estimation&quot;)
plot!(p, xs, density_rot, lw=2, label=&quot;Rule of Thumb Estimation&quot;)
plot!(p, xlabel=&quot;Random Variable&quot;, ylabel=&quot;Density&quot;)</code></pre><p><img src="rot_vs_gradepro.svg" alt/></p><h2 id="Usage-Summary"><a class="docs-heading-anchor" href="#Usage-Summary">Usage Summary</a><a id="Usage-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-Summary" title="Permalink"></a></h2><p>As is exemplified above, it is possible to initialize an estimation using</p><article><details class="docstring" open="true"><summary id="ParallelKDE.initialize_estimation-index"><a class="docstring-binding" href="#ParallelKDE.initialize_estimation-index"><code>ParallelKDE.initialize_estimation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">initialize_estimation(data; kwargs...)</code></pre><p>Initialize a density estimation object based on the provided data.</p><p><strong>Arguments</strong></p><ul><li><code>data::Union{AbstractMatrix,AbstractVector{&lt;:AbstractVector}}</code>: The data to be used for density estimation.</li><li><code>grid::Union{Bool,G&lt;:AbstractGrid}=false</code>: Whether to create a grid for the density estimation.</li></ul><p>If <code>true</code>, a grid will be created based on the data ranges. A grid can also be provided directly.</p><ul><li><code>grid_ranges=nothing</code>: The ranges for the grid coordinates if <code>grid</code> is <code>true</code>.</li></ul><p>This has priority over other grid parameters.</p><ul><li><code>dims=nothing</code>: The dimensions of the grid if <code>grid</code> is <code>true</code>.</li><li><code>grid_bounds=nothing</code>: The bounds for the grid if <code>grid</code> is <code>true</code>.</li><li><code>grid_padding=nothing</code>: Padding for the grid if <code>grid</code> is <code>true</code>.</li><li><code>device=:cpu</code>: The device to use for the density estimation. It should be compatible with the estimator to be used.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = randn(1, 1000);
density_estimation = initialize_estimation(data; grid=true, grid_ranges=-5.0:0.1:5.0, device=:cpu);</code></pre></div></section></details></article><p>Then, the density can be estimated with a chosen estimator and its settings using</p><article><details class="docstring" open="true"><summary id="ParallelKDE.estimate_density!-index"><a class="docstring-binding" href="#ParallelKDE.estimate_density!-index"><code>ParallelKDE.estimate_density!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_density!(density_estimation::DensityEstimation, estimation_method::Symbol; kwargs...)</code></pre><p>Estimate the density using the specified method and update the <code>DensityEstimation</code> object.</p><p>For a list of available estimation methods and their keywords, see the documentation for the specific estimator.</p></div></section></details></article><p>Finally, the estimated density can be accessed using</p><article><details class="docstring" open="true"><summary id="ParallelKDE.KDEs.get_density-Tuple{DensityEstimation}-index"><a class="docstring-binding" href="#ParallelKDE.KDEs.get_density-Tuple{DensityEstimation}-index"><code>ParallelKDE.KDEs.get_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_density(density_estimation::DensityEstimation; normalize=false, dx=nothing)</code></pre><p>Obtain the estimated density from a <code>DensityEstimation</code> object.</p><p>If the <code>normalize</code> argument is set to <code>true</code>, the density will be normalized. If density_estimation has a grid, its spacing will be used for normalization. Otherwise, <code>dx</code> must be provided to normalize the density.</p></div></section></details></article><p>More details regarding the currently implemented estimators as well as further information about the package can be found throughout the documentation.</p><ul><li><a href="api_reference/devices/#APIDevices">Devices Interface</a></li><li><a href="api_reference/direct_space/#APIDirectSpace">Direct Space Interface</a></li><li><a href="api_reference/estimators/#APIEstimators">Estimators Interface</a></li><li><a href="api_reference/fourier_space/#APIFourierSpace">Fourier Space Interface</a></li><li><a href="api_reference/grids/#APIGrids">Grids Interface</a></li><li><a href="api_reference/kdes/#APIKDEs">KDE Interface</a></li><li><a href="api_reference/parallel_kde/#APIParallelKDE">ParallelKDE Interface</a></li><li><a href="contributing/#ContributingSupport">Contributing and Support</a></li><li class="no-marker"><ul><li><a href="contributing/#Community-Guidelines">Community Guidelines</a></li><li><a href="contributing/#Adding-New-Estimators">Adding New Estimators</a></li><li><a href="contributing/#Current-Tools">Current Tools</a></li></ul></li><li><a href="estimators/gradepro/#GradeproEstimator">GradePro Estimator</a></li><li class="no-marker"><ul><li><a href="estimators/gradepro/#Usage">Usage</a></li></ul></li><li><a href="estimators/rot/#RotEstimator">Rules of Thumb Estimator</a></li><li class="no-marker"><ul><li><a href="estimators/rot/#Usage">Usage</a></li></ul></li><li><a href="#ParallelKDE">ParallelKDE</a></li><li class="no-marker"><ul><li><a href="#Basic-Example">Basic Example</a></li><li><a href="#Density-Estimation-for-Conformational-Samples">Density Estimation for Conformational Samples</a></li><li><a href="#GradePro-vs-Rules-of-Thumb">GradePro vs Rules of Thumb</a></li><li><a href="#Usage-Summary">Usage Summary</a></li></ul></li><li><a href="installation/#Installation">Installation</a></li></ul><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://doi.org/10.1063/1.49765">Nüske, F. et al (2017). Markov state models from short non-equilibrium simulations—Analysis and correction of estimation bias. <em>J. Chem. Phys.</em></a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://doi.org/10.1063/1.5011399">Wehmeyer, C. and Noé, F. (2018). Time-lagged autoencoders: deep learning of slow collective variables for molecular kinetics. <em>J. Chem. Phys.</em></a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="installation/">Installation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 22 December 2025 17:55">Monday 22 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
