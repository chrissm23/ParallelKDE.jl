var documenterSearchIndex = {"docs":
[{"location":"api_reference/kdes/#APIKDEs","page":"KDE Interface","title":"KDE Interface","text":"KDE objects store the final result of the estimation. This usually consists of an array of densities mapped to the selected grid. They also store the samples used for the estimation.\n\nThere are currently two concrete KDE types, one for CPU and one for CUDA devices. However, the interface is otherwise the same, so that it is possible to use the same code for both devices. It is also possible to create custom KDE objects that conform to the interface.\n\nThe following is a set of functions that extract information from KDE objects.\n\nIt is possible to create a KDE object from the samples to be used for the estimation with\n\nSetting the density currently stored in the KDE object to a new set of values is done with\n\nwhereas resetting the density to NaN can be done with\n\nCreating sets of sample indices of bootstrap samples from the KDE object is also possible with","category":"section"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.AbstractKDE","page":"KDE Interface","title":"ParallelKDE.KDEs.AbstractKDE","text":"AbstractKDE{N,T,S}\n\nSupertype for kernel density estimation (KDEs) with N dimensions, T type for density values, and S type for data points.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.KDE","page":"KDE Interface","title":"ParallelKDE.KDEs.KDE","text":"KDE{N,T<:Real,S<:Real}\n\nCPU object for kernel density estimation (KDE) with N dimensions, T type for density values, and S type for data points.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.CuKDE","page":"KDE Interface","title":"ParallelKDE.KDEs.CuKDE","text":"CuKDE{N,T<:Real,S<:Real}\n\nCUDA object for kernel density estimation (KDE) with N dimensions, T type for density values, and\n\n\n\n\n\n","category":"type"},{"location":"api_reference/kdes/#ParallelKDE.Devices.get_device","page":"KDE Interface","title":"ParallelKDE.Devices.get_device","text":"get_device(device::Any)\n\nObtain the device object for a given device type.\n\nIf the method is called with an unsupported type, it returns a DeviceNotSpecified object.\n\n\n\n\n\nget_device(grid::AbstractGrid)\n\nIdentify the device type of the grid, returning IsCPU for CPU grids and IsCUDA for CUDA grids.\n\n\n\n\n\nget_device(kde::AbstractKDE)\n\nIdentify the device type used by the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.get_data","page":"KDE Interface","title":"ParallelKDE.KDEs.get_data","text":"get_data(kde::AbstractKDE)\n\nReturn a view of the data stored in the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.get_density-Tuple{ParallelKDE.KDEs.AbstractKDE}","page":"KDE Interface","title":"ParallelKDE.KDEs.get_density","text":"get_density(kde::AbstractKDE)\n\nReturn the density values stored in the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.get_nsamples","page":"KDE Interface","title":"ParallelKDE.KDEs.get_nsamples","text":"get_nsamples(kde::AbstractKDE)\n\nReturn the number of samples in the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.initialize_kde","page":"KDE Interface","title":"ParallelKDE.KDEs.initialize_kde","text":"initialize_kde(data, dims...; device=:cpu)\n\nCreate a kernel density estimation (KDE) object with the given data and dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.set_density!","page":"KDE Interface","title":"ParallelKDE.KDEs.set_density!","text":"set_density!(kde::AbstractKDE, density::AbstractArray)\n\nSet the density values in the kernel density estimation (KDE) object to the provided array.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.set_nan_density!","page":"KDE Interface","title":"ParallelKDE.KDEs.set_nan_density!","text":"set_nan_density!(kde::AbstractKDE)\n\nSet the density values in the kernel density estimation (KDE) object to NaN.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.bootstrap_indices","page":"KDE Interface","title":"ParallelKDE.KDEs.bootstrap_indices","text":"bootstrap_indices(kde::AbstractKDE, n_bootstraps)\n\nObtain a matrix of bootstrap indices for the kernel density estimation (KDE) object.\n\nThe matrix has n_samples rows and n_bootstraps columns, where each column contains indices sampled with replacement from the range 1:n_samples.\n\n\n\n\n\n","category":"function"},{"location":"contributing/#ContributingSupport","page":"Contributing and Support","title":"Contributing and Support","text":"","category":"section"},{"location":"contributing/#Community-Guidelines","page":"Contributing and Support","title":"Community Guidelines","text":"Support: For usage questions or help troubleshooting, please open a GitHub issue including a minimal reproducible example and your Julia and OS versions.\nReport issues: Please open a GitHub issue and include expected vs. actual behavior, steps to reproduce, and a small input example.\nContribute: For small changes, feel free to open a pull request directly on GitHub. For larger changes, please open an issue first to discuss the design, then submit a pull request.","category":"section"},{"location":"contributing/#Adding-New-Estimators","page":"Contributing and Support","title":"Adding New Estimators","text":"To add a new estimator:\n\nCreate a new subtype of the AbstractEstimator interface.\nRegister your new estimator using the add_estimator! function.\nImplement the initialize_estimator method for your type, making use of any available grid, KDE, and device abstractions. This method initializes the state of your estimator.\nImplement the estimate! method for your type. This method should modify the density array in the instance of the AbstractKDE that it takes as argument, and optionally, also modify the estimator's state.\n\nSee the Estimators API for more details on the required methods and how to implement them.","category":"section"},{"location":"contributing/#Current-Tools","page":"Contributing and Support","title":"Current Tools","text":"The package already provides a number of reusable utilities for building new estimators, including:\n\nFramework for device and method management (CPU, CUDA)\nGrid generation and manipulation functions\nDensity object construction and manipulation\nInitialization of approximated empirical distributions\nKernel convolution routines in Fourier space","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"To install ParallelKDE.jl, use Julia's package manager:\n\npkg> add ParallelKDE\n\nOr, with the Pkg API:\n\nusing Pkg\nPkg.add(\"ParallelKDE\")\n\nFor the latest changes, the package can also be installed directly from the repository with:\n\nusing Pkg\nPkg.add(url=\"https://github.com/chrissm23/ParallelKDE.jl\", rev=\"dev\")\n\ncompat: Compatible Julia versions\nParallelKDE.jl supports Julia v1.10+ and is expected to work on Julia 1.x (SemVer: ^1.10).\n\nThis will automatically install the package and its dependencies including CUDA.jl. In order to use CUDA acceleration, please ensure that you have a compatible NVIDIA GPU.\n\nA Python wrapper is also available, allowing users to call estimation routines from Python. For detailed instructions, please refer to the ParallelKDEpy package.","category":"section"},{"location":"api_reference/fourier_space/#APIFourierSpace","page":"Fourier Space Interface","title":"Fourier Space Interface","text":"This module contains low level functions for operating in the frequency domain, including:","category":"section"},{"location":"api_reference/fourier_space/#ParallelKDE.FourierSpace.fourier_statistics!","page":"Fourier Space Interface","title":"ParallelKDE.FourierSpace.fourier_statistics!","text":"fourier_statistics!(device, sk, s2k, plan)\nfourier_statistics!(device, sk, plan)\n\nCalculate the Fourier transform of kernel first and second moments and its bootstrap samples.\n\ndevice specifies the device type, which can be :serial, :threaded, or :cuda. sk and s2k are the complex arrays containing the first and second moments of the kernels. plan is the FFTW plan for the Fourier transform.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/fourier_space/#ParallelKDE.FourierSpace.propagate_statistics!","page":"Fourier Space Interface","title":"ParallelKDE.FourierSpace.propagate_statistics!","text":"propagate_statistics!(device, means_t, variances_t, means_0, variances_0, time_propagated, time_initial, grid_array)\npropagate_statistics!(device, means_t, means_0, time_propagated, grid_array)\n\nPropagate the first and second moments of the kernels to larger bandwidths.\n\nArguments\n\nVal(device): Specifies the device type, which can be :serial, :threaded, or :cuda.\nmeans_t: The complex array where the propagated first moments of the kernels will be stored.\nmeans_0: The complex array containing the initial first moments of the kernels.\nvariances_t: The complex array where the propagated second moments of the kernels will be stored.\nvariances_0: The complex array containing the initial second moments of the kernels.\ntime_propagated: A vector of real numbers representing the time points at which the kernels are propagated.\ntime_initial: A vector of real numbers representing the initial time points of the kernels.\ngrid_array: An array of real numbers representing the grid points in the Fourier space.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/fourier_space/#ParallelKDE.FourierSpace.ifourier_statistics!","page":"Fourier Space Interface","title":"ParallelKDE.FourierSpace.ifourier_statistics!","text":"ifourier_statistics!(device, sk, s2k, ifft_plan)\nifourier_statistics!(device, sk, ifft_plan)\n\nCalculate the inverse Fourier transform of kernel first and second moments and its bootstrap samples.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/devices/#APIDevices","page":"Devices Interface","title":"Devices Interface","text":"The devices interface lets you specify where computations should run for a specific object.\n\nAny object that is meant to run on a specific device should implement the get_device method to make use of this interface.\n\nAdditionally, a device may have one or more methods that it has available for use as well default methods when the user does not specify one. Furthermore, a Symbol may be used to identify a device type. These methods are registered in dictionaries in the Devices.jl module.\n\nThis dictionaries can be used to query the validity of a selected method for a device.\n\nSince GPU devices may work more efficiently with single-precision numbers, the package provides a method to convert double precision numbers to single precision when possible.","category":"section"},{"location":"api_reference/devices/#ParallelKDE.Devices.AbstractDevice","page":"Devices Interface","title":"ParallelKDE.Devices.AbstractDevice","text":"AbstractDevice\n\nSupertype for all device types.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/#ParallelKDE.Devices.IsCPU","page":"Devices Interface","title":"ParallelKDE.Devices.IsCPU","text":"IsCPU <: AbstractDevice\n\nType representing a CPU device.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/#ParallelKDE.Devices.IsCUDA","page":"Devices Interface","title":"ParallelKDE.Devices.IsCUDA","text":"IsCUDA <: AbstractDevice\n\nType representing a CUDA-enabled GPU device.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/#ParallelKDE.Devices.DeviceNotSpecified","page":"Devices Interface","title":"ParallelKDE.Devices.DeviceNotSpecified","text":"DeviceNotSpecified <: AbstractDevice\n\nType representing a device that has not been specified or is unsupported.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/#ParallelKDE.Devices.get_device-Tuple{Any}","page":"Devices Interface","title":"ParallelKDE.Devices.get_device","text":"get_device(device::Any)\n\nObtain the device object for a given device type.\n\nIf the method is called with an unsupported type, it returns a DeviceNotSpecified object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/devices/#ParallelKDE.Devices.AVAILABLE_DEVICES","page":"Devices Interface","title":"ParallelKDE.Devices.AVAILABLE_DEVICES","text":"AVAILABLE_DEVICES\n\nRelate a Symbol to the corresponding device type.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/devices/#ParallelKDE.Devices.DEVICE_IMPLEMENTATIONS","page":"Devices Interface","title":"ParallelKDE.Devices.DEVICE_IMPLEMENTATIONS","text":"DEVICE_IMPLEMENTATIONS\n\nRelate the device types to their available implementations.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/devices/#ParallelKDE.Devices.DEFAULT_IMPLEMENTATIONS","page":"Devices Interface","title":"ParallelKDE.Devices.DEFAULT_IMPLEMENTATIONS","text":"DEFAULT_IMPLEMENTATIONS\n\nRelate the device types to their default implementations.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/devices/#ParallelKDE.Devices.ensure_valid_implementation","page":"Devices Interface","title":"ParallelKDE.Devices.ensure_valid_implementation","text":"ensure_valid_implementation(device::AbstractDevice, implementation::Symbol)\n\nEnsure that the specified implementation is valid for the given device.\n\nIf the implementation is not valid, an ArgumentError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/devices/#ParallelKDE.Devices.convert32","page":"Devices Interface","title":"ParallelKDE.Devices.convert32","text":"convert32(x)\n\nConverts into a 32-bit representation if x is a Float64, CuArray{Float64}, or Array{Float64}.\n\n\n\n\n\nconvert32(args...; kwargs...)\n\nIf multiple arguments are provided, converts each argument to a 32-bit representation if applicable, and returns a tuple of the converted arguments and a dictionary of converted keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"estimators/rot/#RotEstimator","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"The Rules of Thumb Estimator (ROT) is the estimator for calculating the bandwidth of a kernel density estimation based on rules of thumb. It is particularly useful when you want to quickly estimate the bandwidth if your underlying data is close to a Gaussian distribution.\n\nThere are currently two implemented rules of thumb:\n\nSilverman's rule [1]\nScott's rule [2]","category":"section"},{"location":"estimators/rot/#Usage","page":"Rules of Thumb Estimator","title":"Usage","text":"To use this estimator, call the estimate_density! method and pass :rot to the estimation_method argument.\n\nestimate_density!(density_estimation, :rot; kwargs...)","category":"section"},{"location":"estimators/rot/#Available-Keyword-Arguments","page":"Rules of Thumb Estimator","title":"Available Keyword Arguments","text":"method: The method to use for the estimation. Options are :serial, :threaded, or :cuda. Default is :serial for CPU and :cuda must be selected for CUDA devices.\nrule_of_thumb: The rule of thumb to use for the bandwidth estimation. Current options are :silverman or :scott. Default is :scott.\n\nwarning: High dimensionality with CUDA\nImplementation with CUDA was not written to support higher dimensionality than 3D estimations.\n\n[1]: Silverman, B. W. (1986). Density Estimation for Statistics and Data Analysis. Chapman and Hall/CRC.\n\n[2]: Scott, D. W. (1992). Multivariate Density Estimation: Theory, Practice, and Visualization. Wiley & Sons.","category":"section"},{"location":"estimators/gradepro/#GradeproEstimator","page":"GradePro Estimator","title":"GradePro Estimator","text":"The GradePro Estimator is the primary estimator provided by the package. It is designed to operate on dense regular grids and is optimized for parallel performance across different hardware configurations:\n\nSerial (single-threaded)\nThreaded (multi-core CPU)\nCUDA (GPU acceleration)\n\nThe underlying ideas for this estimator can be found in Sustay Martinez et al[1].","category":"section"},{"location":"estimators/gradepro/#Usage","page":"GradePro Estimator","title":"Usage","text":"To use this estimator, call the estimate_density! method and pass :gradepro to the estimation_method argument.\n\nestimate_density!(density_estimation, :gradepro; kwargs...)","category":"section"},{"location":"estimators/gradepro/#Available-Keyword-Arguments","page":"GradePro Estimator","title":"Available Keyword Arguments","text":"method: The method to use for the estimation. Options are :serial, :threaded, or :cuda. Default is :serial for CPU and :cuda must be selected for CUDA devices.\nn_bootstraps: Number of bootstraps to use for the estimation. Default is 100.\nbw_final: Maximum bandwidth to iterate to. Default is given by Silverman's rule.\nbw_step: Size of the bandwidth step between iterations. Default is chosen for 250 iterations.\nn_steps: Number of iterations to perform. Default is 250. This has precedence over bw_step.\nalpha_s: Percentage of the total bandwidth steps of persistence beyond the thresholds before registering the crossing event. Default is 0.0 (0%) for 1D, and 0.06 (6%) for 2D.\nalpha_os: Maximum percentage of the total bandwidth steps allowed before the next estimation update for halting the estimated density updates. Default is 0.1 (10%).\neps: Threshold for convergence of low density regions. Default is 2.0 for 1D, and -0.5 for 2D.\n\nwarning: Parameters for higher dimensions\nCurrently there are no tested parameters for estimations of dimensionality higher than 2D. The default in those cases is to use the 2D parameters.\n\nwarning: High dimensionality with CUDA\nImplementation with CUDA was not written to support higher dimensionality than 3D estimations.\n\n[1]: [Sustay Martinez, C., Quoika P. K., Zacharias, M. (2025). Novel Rapid Approach for Adaptive Gaussian Kernel Density Estimation: Gridpoint-wise Propagation of Anisotropic Diffusion Equation]","category":"section"},{"location":"api_reference/direct_space/#APIDirectSpace","page":"Direct Space Interface","title":"Direct Space Interface","text":"This module contains low level functions for operating on arrays in the original (spatial) domain. These include:","category":"section"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.initialize_dirac_sequence","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.initialize_dirac_sequence","text":"initialize_dirac_sequence(data; kwargs...)\n\nCreate a Dirac sequence based on the provided data points.\n\nArguments\n\ndata: A matrix or vector of data points, where each column represents a sample.\ngrid: (optional) A grid object defining the grid on which the Dirac sequence is initialized.\nbootstrap_idxs: (optional) A matrix of indices for bootstrap resampling.\ndevice: (optional) The device type to use for computation, default is :cpu.\nmethod: (optional) The method to use for computation, default is determined by the device.\ninclude_var: (optional) If true, includes variance in the Dirac sequence, default is false.\nT: (optional) The type of the elements in the Dirac sequence, default is Float64 for CPU and Float32 for CUDA.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.calculate_scaled_vmr!","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.calculate_scaled_vmr!","text":"calculate_scaled_vmr!(\n  method::Val{device},\n  sk::AbstractArray{Complex{T},M},\n  s2k::AbstractArray{Complex{T},M},\n  time::AbstractVector{<:Real},\n  time_initial::AbstractVector{<:Real},\n  n_samples::Integer\n)\n\nCalculate the scaled variance-to-mean ratio (VMR) for an array of kernel means and kernel variances.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.calculate_full_means!","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.calculate_full_means!","text":"calculate_full_means!(method::Val{Symbol}, sk::AbstractArray{Complex{T},N}, n_samples::Integer)\n\nCalculate the means of the kernels of the full sample set.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.identify_convergence!","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.identify_convergence!","text":"identify_convergence!\n\nIdentify the points in the grid that have converged based on the variance-to-mean ratio (VMR) and update the density accordingly.\n\nArguments\n\nVal(Symbol): The method type, e.g., :serial, :threaded, or :cuda.\ndensity: The density array to be updated.\nmeans: The means array corresponding to the density.\nvmrs_current: The current VMR values.\nvmrs_prev1: The previous VMR values.\nvmrs_prev2: The VMR values from two steps back.\ndlogt: The logarithmic time step.\ntol_low_id: The tolerance to identify low density regions.\nsteps_low: The number of steps to consider for threshold crossing to avoid effects of noise.\nsteps_over: The number of steps to consider without updates to declare convergence.\ncurrent_minima: The current minima array to be updated.\ncounters_low: The counter to identify low density regions.\ncounters_over: The counter to identify over-smoothing of high density regions.\nlow_density_flags: Flags indicating low density regions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/estimators/#APIEstimators","page":"Estimators Interface","title":"Estimators Interface","text":"This module contains the estimator definitions and dispatch infrastructure. Each estimator must implement the required interface to integrate with the current framework.\n\nIf you are implementing you own estimator, use this API as your reference point for compliance.\n\nThe supertype for all estimators is AbstractEstimator, as described below.\n\nEstimators need to be registered so that users can access them using a symbol as a name. This is done with:\n\nThe function that will be called by the User API to create an estimator is:\n\nwhich requires the following methods to be implemented for the estimator:","category":"section"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.AbstractEstimator","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.AbstractEstimator","text":"AbstractEstimator\n\nSupertype for all density estimation estimators.\n\nThis is the base for all object that are intended to provide a method for estimating the density. They store all the necessary parameters and data for the estimation process.\n\nSee also ParallelKDE.AbstractDensityEstimation for the base type where the estimated density is stored.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.add_estimator!","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.add_estimator!","text":"add_estimator!(key::Symbol, value::Type{<:AbstractEstimator})\n\nInclude a new estimator type into the lookup table.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.estimate!-Tuple{Symbol, ParallelKDE.KDEs.AbstractKDE}","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.estimate!","text":"estimate!(estimator_name::Symbol, kde::AbstractKDE; kwargs...)\n\nEstimate the density of an AbstractKDE object using the specified estimator type.\n\nThe estimator_name should be a symbol that corresponds to the key in the estimator_lookup dictionary. Therefore, this is the method that the ParallelKDE.jl API uses to estimate the density.\n\nSee add_estimator! for how to add a new estimator type to the lookup table.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.initialize_estimator","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.initialize_estimator","text":"initialize_estimator(::Type{<:AbstractEstimator}, kde::AbstractKDE; kwargs...)\n\nInitialize an instance of the given estimator type with the provided KDE object and keyword arguments.\n\nEach estimator type should implement this method to set up its internal state based on the KDE data.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.estimate!-Tuple{ParallelKDE.DensityEstimators.AbstractEstimator, ParallelKDE.KDEs.AbstractKDE}","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.estimate!","text":"estimate!(estimator_type::AbstractEstimator, kde::AbstractKDE; kwargs...)\n\nDefined this way is how each estimator type should implement the estimation process.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#APIGrids","page":"Grids Interface","title":"Grids Interface","text":"Grids define the space over which the KDE is computed. The package supports:\n\nRegular, Cartesian grids\nUser-defined bounds and resolution\nGrid selection based on data distribution\n\nThere are currently two concrete grid types, one for CPU and one for CUDA devices. However, the interface is otherwise the same, so that it is possible to use the same code for both devices. It is also possible to create custom grids that conform to the interface.\n\nThere is a set of features that can be extracted from grid objects. This is done by the following methods:\n\nIt is possible to create a grid with the desired ranges with\n\nas well as to create a grid appropriate for the data using\n\nFor convenience, the package includes a method to create a grid for Fourier space from a grid in direct space:","category":"section"},{"location":"api_reference/grids/#ParallelKDE.Grids.AbstractGrid","page":"Grids Interface","title":"ParallelKDE.Grids.AbstractGrid","text":"AbstractGrid{N,T<:Real,M}\n\nSupertype for all grid types, where N is the number of dimensions, T is the type of the coordinates (usually Float64 or Float32), and M is the number of dimensions in the underlying array (usually N + 1).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/grids/#ParallelKDE.Grids.Grid","page":"Grids Interface","title":"ParallelKDE.Grids.Grid","text":"Grid{N,T<:Real,M}\n\nCPU object for a grid with N dimensions, T type for coordinates, and M=N+1 dimensions for the underlying array.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/grids/#ParallelKDE.Grids.CuGrid","page":"Grids Interface","title":"ParallelKDE.Grids.CuGrid","text":"CuGrid{N,T<:Real,M}\n\nCUDA object for a grid with N dimensions, T type for coordinates, and M=N+1 dimensions for the underlying array.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/grids/#Base.size-Tuple{ParallelKDE.Grids.AbstractGrid}","page":"Grids Interface","title":"Base.size","text":"size(grid::AbstractGrid)\n\nReturn the size of the grid, which is a tuple containing the number of points in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#Base.ndims-Tuple{ParallelKDE.Grids.AbstractGrid}","page":"Grids Interface","title":"Base.ndims","text":"ndims(grid::AbstractGrid)\n\nReturn the number of dimensions of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#ParallelKDE.Grids.get_coordinates","page":"Grids Interface","title":"ParallelKDE.Grids.get_coordinates","text":"get_coordinates(grid::AbstractGrid)\n\nReturn a view of the coordinates of the grid as an array.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Devices.get_device-Tuple{ParallelKDE.Grids.AbstractGrid}","page":"Grids Interface","title":"ParallelKDE.Devices.get_device","text":"get_device(device::Any)\n\nObtain the device object for a given device type.\n\nIf the method is called with an unsupported type, it returns a DeviceNotSpecified object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#ParallelKDE.Grids.spacings","page":"Grids Interface","title":"ParallelKDE.Grids.spacings","text":"spacings(grid::AbstractGrid)\n\nReturn the spacings of the grid, which is a vector containing the spacing between points in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.bounds","page":"Grids Interface","title":"ParallelKDE.Grids.bounds","text":"bounds(grid::AbstractGrid)\n\nReturn the bounds of the grid, which is a 2xN matrix containing the minimum and maximum values for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.low_bounds","page":"Grids Interface","title":"ParallelKDE.Grids.low_bounds","text":"low_bounds(grid::AbstractGrid)\n\nReturn the lower bounds of the grid, which is a vector containing the minimum values for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.high_bounds","page":"Grids Interface","title":"ParallelKDE.Grids.high_bounds","text":"high_bounds(grid::AbstractGrid)\n\nReturn the upper bounds of the grid, which is a vector containing the maximum values for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.initial_bandwidth","page":"Grids Interface","title":"ParallelKDE.Grids.initial_bandwidth","text":"initial_bandwidth(grid::AbstractGrid)\n\nReturn the initial bandwidth for the grid, which is half of the spacings in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.initialize_grid","page":"Grids Interface","title":"ParallelKDE.Grids.initialize_grid","text":"initialize_grid(ranges; device=:cpu, b32=false)\ninitialize_grid(ranges...; device=:cpu, b32=false)\n\nCreate a grid object based on the provided ranges of coordinates for each dimension.\n\ndevice specifies the device type (default is :cpu but :cuda is also implemented), and, if a GPU is used, b32 determines whether to use Float32 or Float64 for the grid coordinates. For CPU grids, b32 is ignored and the data type matches the data type of ranges.\n\nExamples\n\ninitialize_grid(0.0:0.1:1.0, 0.0:0.1:1.0, device=:cuda, b32=true)\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.find_grid","page":"Grids Interface","title":"ParallelKDE.Grids.find_grid","text":"find_grid(data; kwargs...)\n\nFind a grid based on the provided data, which can be a matrix or a vector of vectors.\n\nArguments\n\ndata: The input data, which can be an AbstractMatrix or an AbstractVector of vectors.\ngrid_bounds: Optional bounds for the grid. If not provided, bounds are calculated from the data.\ngrid_dims: Optional dimensions for the grid. If not provided, defaults to 300 points in each dimension.\ngrid_steps: Optional spacing steps for the grid to be used instead of dimensions. grid_dims takes precedence.\ngrid_padding: Optional padding for the grid bounds. If not provided, defaults to 10% of the range.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.fftgrid","page":"Grids Interface","title":"ParallelKDE.Grids.fftgrid","text":"fftgrid(grid::AbstractGrid)\n\nCalculate the Fourier grid based on the spacings of the input grid. The Fourier grid contains frequencies corresponding to the grid points in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#APIParallelKDE","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"This is the main module users interact with. It re-exports the essential tools to:\n\nDefine and configure estimators\nRun KDEs on different devices (CPU, CUDA)\nAccess results and manipulate densities\n\nCurrently, the main objects for the estimation are:\n\nIt is possible to initialize the estimation object with:\n\nEstimation objects are designed to support a grid for grid-based density estimation. However, this is not mandatory. To test if a grid is present and obtain a grid object, you can use:\n\nExecuting the estimation and obtaining the density is done with:","category":"section"},{"location":"api_reference/parallel_kde/#ParallelKDE.AbstractDensityEstimation","page":"ParallelKDE Interface","title":"ParallelKDE.AbstractDensityEstimation","text":"AbstractDensityEstimation\n\nSupertype for all density estimation objects.\n\nThis is the base for all objects that intended to store the estimated density, and, optionally, the grid on which the density is estimated.\n\nSee also DensityEstimation for the concrete implementation.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/parallel_kde/#ParallelKDE.DensityEstimation","page":"ParallelKDE Interface","title":"ParallelKDE.DensityEstimation","text":"DensityEstimation{K<:AbstractKDE,G<:Union{Nothing,AbstractGrid}}\n\nConcrete type for density estimation objects.\n\nThis type holds a kernel density estimation (KDE) object kde and an optional grid grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/parallel_kde/#ParallelKDE.initialize_estimation","page":"ParallelKDE Interface","title":"ParallelKDE.initialize_estimation","text":"initialize_estimation(data; kwargs...)\n\nInitialize a density estimation object based on the provided data.\n\nArguments\n\ndata::Union{AbstractMatrix,AbstractVector{<:AbstractVector}}: The data to be used for density estimation.\ngrid::Union{Bool,G<:AbstractGrid}=false: Whether to create a grid for the density estimation.\n\nIf true, a grid will be created based on the data ranges. A grid can also be provided directly.\n\ngrid_ranges=nothing: The ranges for the grid coordinates if grid is true.\n\nThis has priority over other grid parameters.\n\ndims=nothing: The dimensions of the grid if grid is true.\ngrid_bounds=nothing: The bounds for the grid if grid is true.\ngrid_padding=nothing: Padding for the grid if grid is true.\ndevice=:cpu: The device to use for the density estimation. It should be compatible with the estimator to be used.\n\nExamples\n\ndata = randn(1, 1000);\ndensity_estimation = initialize_estimation(data; grid=true, grid_ranges=-5.0:0.1:5.0, device=:cpu);\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#ParallelKDE.has_grid","page":"ParallelKDE Interface","title":"ParallelKDE.has_grid","text":"has_grid(density_estimation::DensityEstimation)\n\nReturn true if the DensityEstimation object has a grid associated with it, false otherwise.\n\nExamples\n\ndata = randn(1, 1000);\ndensity_estimation = initialize_estimation(data; grid=true, grid_ranges=-5.0:0.1:5.0, device=:cpu);\nhas_grid(density_estimation)\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#ParallelKDE.get_grid","page":"ParallelKDE Interface","title":"ParallelKDE.get_grid","text":"get_grid(density_estimation::DensityEstimation)\n\nExtract the grid from a DensityEstimation object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#ParallelKDE.estimate_density!","page":"ParallelKDE Interface","title":"ParallelKDE.estimate_density!","text":"estimate_density!(density_estimation::DensityEstimation, estimation_method::Symbol; kwargs...)\n\nEstimate the density using the specified method and update the DensityEstimation object.\n\nFor a list of available estimation methods and their keywords, see the documentation for the specific estimator.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#ParallelKDE.KDEs.get_density-Tuple{DensityEstimation}","page":"ParallelKDE Interface","title":"ParallelKDE.KDEs.get_density","text":"get_density(density_estimation::DensityEstimation; normalize=false, dx=nothing)\n\nObtain the estimated density from a DensityEstimation object.\n\nIf the normalize argument is set to true, the density will be normalized. If density_estimation has a grid, its spacing will be used for normalization. Otherwise, dx must be provided to normalize the density.\n\n\n\n\n\n","category":"method"},{"location":"#ParallelKDE","page":"Home","title":"ParallelKDE","text":"ParallelKDE is a package for flexible and efficient kernel density estimation (KDE), with a strong focus on parallel implementations. Its core estimator, the GradePro Estimator described here, supports CPU and GPU acceleration (threaded and CUDA), and its designed to scale with modern hardware. While the package is centered around grid-based KDEs, it also provides extensible infrastructure to support and implement other types of estimators.\n\nThe user interface is built around a modular design that separates concerns between grids, devices, density objects and estimation routines. This allows users to easily switch estimators, control execution targets (e.g., CPU or GPU), and prototype new estimation strategies without rewriting boilerplate code.\n\nTypical usage involves:\n\nInstantiating an estimation in a specific device (e.g., CPU, CUDA),\nThis also involves defining a grid for the estimation or using a default grid,\nEstimating the density with a chosen estimator,\nAccessing the resulting density.","category":"section"},{"location":"#Basic-Example","page":"Home","title":"Basic Example","text":"For example, to estimate a density on a CPU with a default grid using the GradePro Estimator, you can use:\n\nusing ParallelKDE\n\ndata = randn(1, 10000) # 1-dimensional sample of 10000 points\n\ndensity_estimation = initialize_estimation(\n  data,\n  grid=true, # default grid\n  device=:cpu,\n)\nestimate_density!(\n  density_estimation,\n  :gradepro,\n)\n\ndensity_estimated = get_density(density_estimation)\nnothing # hide\n\nWe can evaluate the standard normal distribution for comparison:\n\nusing Distributions\n\ngrid_coordinates = get_coordinates(get_grid(density_estimation))[1, :]\ndensity_true = pdf.(Normal(), grid_coordinates)\nnothing # hide\n\nwhich would yield a plot like this:\n\nENV[\"GKSwstype\"]=\"nul\" # hide\nusing Plots\n\np = plot(grid_coordinates, density_true, label=\"True Density\", color=:cornflowerblue, lw=2)\nplot!(p, grid_coordinates, density_estimated, label=\"Estimated Density\", color=:firebrick, lw=2)\nplot!(p, xlabel=\"Random Variable\", ylabel=\"Density\")\nsavefig(\"basic_usage.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"#Density-Estimation-for-Conformational-Samples","page":"Home","title":"Density Estimation for Conformational Samples","text":"Here, we exemplify the use of ParallelKDE to estimate the conformational density of alanine dipeptide via dihedral angles.\n\nWe start by downloading and reading the dataset of dihedral angles obtained from molecular dynamics trajectories [1] [2].\n\nusing Downloads\nusing NPZ\n\nurl = \"http://ftp.imp.fu-berlin.de/pub/cmb-data/alanine-dipeptide-3x250ns-backbone-dihedrals.npz\"\ndest = joinpath(pwd(), \"ala_dipeptide_dihderals.npz\")\nDownloads.download(url, dest)\n\nala_npz = npzread(dest)\nala = vcat(values(ala_npz)...)\n# afterwards one may need to subsample the dataset to obtain uncorrelated samples.\nnothing # hide\n\nThis time around we will define the grid that we want to use for the estimation instead of using the default grid:\n\nusing ParallelKDE\n\nphi_range, psi_range = fill(range(-π, π, length=250), 2)\ndihedral_grid = initialize_grid([phi_range, psi_range], device=:cpu) # or device=:cuda\n\ndensity_estimation = initialize_estimation(\n  ala', grid=dihedral_grid, device=:cpu # or device=:cuda\n)\nestimate_density!(density_estimation, :gradepro)\nestimated_density = get_density(density_estimation)\nnothing # hide\n\nFinally, we can create a contour plot of the estimated density:\n\nENV[\"GKSwstype\"]=\"nul\" # hide\nusing Plots\nusing LaTeXStrings\n\np = contourf(phi_range, psi_range, estimated_density')\nplot!(p, xlabel=L\"$\\phi$\", ylabel=L\"$\\psi$\", colorbar_title=\"Estimated Density\")\nsavefig(\"ala_dihedrals.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"#GradePro-vs-Rules-of-Thumb","page":"Home","title":"GradePro vs Rules of Thumb","text":"ParallelKDE also provides a Rules of Thumb Estimator for bandwidth selection based on widely used rule-of-thumb heuristics. As with the GradePro Estimator, this estimator is available in both serial and CUDA variants. In practice, the Rules of Thumb approach can be extremely fast and yields competitive accuracy when the sample distribution is close to Gaussian; however, its performance can degrade rapidly as the underlying distribution departs from Gaussianity. Now, we illustrate this trade-off by comparing results produced by both estimators on samples drawn from a bimodal distribution.\n\nWe first initialize the distribution and obtain samples from it:\n\nusing Distributions\n\ndistro = MixtureModel(\n  Normal[\n    Normal(-6.0, 0.2),\n    Normal(0.0, 2),\n  ]\n)\nsamples = rand(distro, 1, 10000) # 1-dimensional sample of 10000 points\nnothing # hide\n\nWe can again initialize a grid and the estimations for both methods with:\n\nusing ParallelKDE\n\nxs = range(-10, 10, length=250)\n\ngrid_bimodal = initialize_grid([xs], device=:cpu) # or device=:cuda\n\nestimation_gradepro = initialize_estimation(\n  samples, grid=grid_bimodal, device=:cpu # or device=:cuda\n)\nestimation_rot = initialize_estimation(\n  samples, grid=grid_bimodal, device=:cpu # or device=:cuda\n)\nnothing # hide\n\nNow we can execute both estimations and calculate the true density with:\n\nestimate_density!(estimation_gradepro, :gradepro)\ndensity_gradepro = get_density(estimation_gradepro)\n\nestimate_density!(estimation_rot, :rot)\ndensity_rot = get_density(estimation_rot)\n\ndensity_true = pdf.(distro, xs)\nnothing # hide\n\nFinally, we can visualize the results with:\n\nENV[\"GKSwstype\"]=\"nul\" # hide\nusing Plots\n\np = plot(xs, density_true, lw=3, ls=:dash, label=\"True Distribution\")\nplot!(p, xs, density_gradepro, lw=2, label=\"GradePro Estimation\")\nplot!(p, xs, density_rot, lw=2, label=\"Rule of Thumb Estimation\")\nplot!(p, xlabel=\"Random Variable\", ylabel=\"Density\")\nsavefig(\"rot_vs_gradepro.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"#Usage-Summary","page":"Home","title":"Usage Summary","text":"As is exemplified above, it is possible to initialize an estimation using\n\nThen, the density can be estimated with a chosen estimator and its settings using\n\nFinally, the estimated density can be accessed using\n\nMore details regarding the currently implemented estimators as well as further information about the package can be found throughout the documentation.\n\n\n\n[1]: Nüske, F. et al (2017). Markov state models from short non-equilibrium simulations—Analysis and correction of estimation bias. J. Chem. Phys.\n\n[2]: Wehmeyer, C. and Noé, F. (2018). Time-lagged autoencoders: deep learning of slow collective variables for molecular kinetics. J. Chem. Phys.","category":"section"},{"location":"#ParallelKDE.initialize_estimation-index","page":"Home","title":"ParallelKDE.initialize_estimation","text":"initialize_estimation(data; kwargs...)\n\nInitialize a density estimation object based on the provided data.\n\nArguments\n\ndata::Union{AbstractMatrix,AbstractVector{<:AbstractVector}}: The data to be used for density estimation.\ngrid::Union{Bool,G<:AbstractGrid}=false: Whether to create a grid for the density estimation.\n\nIf true, a grid will be created based on the data ranges. A grid can also be provided directly.\n\ngrid_ranges=nothing: The ranges for the grid coordinates if grid is true.\n\nThis has priority over other grid parameters.\n\ndims=nothing: The dimensions of the grid if grid is true.\ngrid_bounds=nothing: The bounds for the grid if grid is true.\ngrid_padding=nothing: Padding for the grid if grid is true.\ndevice=:cpu: The device to use for the density estimation. It should be compatible with the estimator to be used.\n\nExamples\n\ndata = randn(1, 1000);\ndensity_estimation = initialize_estimation(data; grid=true, grid_ranges=-5.0:0.1:5.0, device=:cpu);\n\n\n\n\n\n","category":"function"},{"location":"#ParallelKDE.estimate_density!-index","page":"Home","title":"ParallelKDE.estimate_density!","text":"estimate_density!(density_estimation::DensityEstimation, estimation_method::Symbol; kwargs...)\n\nEstimate the density using the specified method and update the DensityEstimation object.\n\nFor a list of available estimation methods and their keywords, see the documentation for the specific estimator.\n\n\n\n\n\n","category":"function"},{"location":"#ParallelKDE.KDEs.get_density-Tuple{DensityEstimation}-index","page":"Home","title":"ParallelKDE.KDEs.get_density","text":"get_density(density_estimation::DensityEstimation; normalize=false, dx=nothing)\n\nObtain the estimated density from a DensityEstimation object.\n\nIf the normalize argument is set to true, the density will be normalized. If density_estimation has a grid, its spacing will be used for normalization. Otherwise, dx must be provided to normalize the density.\n\n\n\n\n\n","category":"method"}]
}
