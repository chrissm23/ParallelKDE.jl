var documenterSearchIndex = {"docs":
[{"location":"api_reference/kdes/#APIKDEs","page":"KDE Interface","title":"KDE Interface","text":"","category":"section"},{"location":"api_reference/kdes/","page":"KDE Interface","title":"KDE Interface","text":"KDE objects store the final result of the estimation. This usually consists of an array of densities mapped to the selected grid. They also store the samples used for the estimation.","category":"page"},{"location":"api_reference/kdes/","page":"KDE Interface","title":"KDE Interface","text":"There are currently two concrete KDE types, one for CPU and one for CUDA devices. However, the interface is otherwise the same, so that it is possible to use the same code for both devices. It is also possible to create custom KDE objects that conform to the interface.","category":"page"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.AbstractKDE","page":"KDE Interface","title":"ParallelKDE.KDEs.AbstractKDE","text":"AbstractKDE{N,T,S}\n\nSupertype for kernel density estimation (KDEs) with N dimensions, T type for density values, and S type for data points.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.KDE","page":"KDE Interface","title":"ParallelKDE.KDEs.KDE","text":"KDE{N,T<:Real,S<:Real}\n\nCPU object for kernel density estimation (KDE) with N dimensions, T type for density values, and S type for data points.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.CuKDE","page":"KDE Interface","title":"ParallelKDE.KDEs.CuKDE","text":"CuKDE{N,T<:Real,S<:Real}\n\nCUDA object for kernel density estimation (KDE) with N dimensions, T type for density values, and\n\n\n\n\n\n","category":"type"},{"location":"api_reference/kdes/","page":"KDE Interface","title":"KDE Interface","text":"The following is a set of functions that extract information from KDE objects.","category":"page"},{"location":"api_reference/kdes/#ParallelKDE.Devices.get_device","page":"KDE Interface","title":"ParallelKDE.Devices.get_device","text":"get_device(device::Any)\n\nObtain the device object for a given device type.\n\nIf the method is called with an unsupported type, it returns a DeviceNotSpecified object.\n\n\n\n\n\nget_device(grid::AbstractGrid)\n\nIdentify the device type of the grid, returning IsCPU for CPU grids and IsCUDA for CUDA grids.\n\n\n\n\n\nget_device(kde::AbstractKDE)\n\nIdentify the device type used by the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.get_data","page":"KDE Interface","title":"ParallelKDE.KDEs.get_data","text":"get_data(kde::AbstractKDE)\n\nReturn a view of the data stored in the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.get_density-Tuple{ParallelKDE.KDEs.AbstractKDE}","page":"KDE Interface","title":"ParallelKDE.KDEs.get_density","text":"get_density(kde::AbstractKDE)\n\nReturn the density values stored in the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.get_nsamples","page":"KDE Interface","title":"ParallelKDE.KDEs.get_nsamples","text":"get_nsamples(kde::AbstractKDE)\n\nReturn the number of samples in the kernel density estimation (KDE) object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/","page":"KDE Interface","title":"KDE Interface","text":"It is possible to create a KDE object from the samples to be used for the estimation with","category":"page"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.initialize_kde","page":"KDE Interface","title":"ParallelKDE.KDEs.initialize_kde","text":"initialize_kde(data, dims...; device=:cpu)\n\nCreate a kernel density estimation (KDE) object with the given data and dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/","page":"KDE Interface","title":"KDE Interface","text":"Setting the density currently stored in the KDE object to a new set of values is done with","category":"page"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.set_density!","page":"KDE Interface","title":"ParallelKDE.KDEs.set_density!","text":"set_density!(kde::AbstractKDE, density::AbstractArray)\n\nSet the density values in the kernel density estimation (KDE) object to the provided array.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/","page":"KDE Interface","title":"KDE Interface","text":"whereas resetting the density to NaN can be done with","category":"page"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.set_nan_density!","page":"KDE Interface","title":"ParallelKDE.KDEs.set_nan_density!","text":"set_nan_density!(kde::AbstractKDE)\n\nSet the density values in the kernel density estimation (KDE) object to NaN.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/kdes/","page":"KDE Interface","title":"KDE Interface","text":"Creating sets of sample indices of bootstrap samples from the KDE object is also possible with","category":"page"},{"location":"api_reference/kdes/#ParallelKDE.KDEs.bootstrap_indices","page":"KDE Interface","title":"ParallelKDE.KDEs.bootstrap_indices","text":"bootstrap_indices(kde::AbstractKDE, n_bootstraps)\n\nObtain a matrix of bootstrap indices for the kernel density estimation (KDE) object.\n\nThe matrix has n_samples rows and n_bootstraps columns, where each column contains indices sampled with replacement from the range 1:n_samples.\n\n\n\n\n\n","category":"function"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"This section is for contributors and advanced users interested in extending or modifying the package. To request features or report issues, please open an issue on GitHub.","category":"page"},{"location":"development/#Adding-new-estimators","page":"Development","title":"Adding new estimators","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"To add a new estimator:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Create a new subtype of the AbstractEstimator interface.\nRegister your new estimator using the add_estimator! function.\nImplement the initialize_estimator method for your type, making use of any available grid, KDE, and device abstractions. This method initializes the state of your estimator.\nImplement the estimate! method for your type. This method should modify the density array in the instance of the AbstractKDE that it takes as argument, and optionally, also modify the estimator's state.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"See the Estimators API for more details on the required methods and how to implement them.","category":"page"},{"location":"development/#Current-tools","page":"Development","title":"Current tools","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"The package already provides a number of reusable utilities for building new estimators, including:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"Framework for device and method management (CPU, CUDA)\nGrid generation and manipulation functions\nDensity object construction and manipulation\nInitialization of approximated empirical distributions\nKernel convolution routines in Fourier space","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To install ParallelKDE.jl, use Julia's package manager:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add ParallelKDE","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Or, with the Pkg API:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"ParallelKDE\")","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"This will automatically install the package and its dependencies including CUDA.jl. In order to use CUDA acceleration, please ensure that you have a compatible NVIDIA GPU.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"A Python wrapper is also available, allowing users to call estimation routines from Python. For detailed instructions, please refer to the ParallelKDEpy package.","category":"page"},{"location":"api_reference/fourier_space/#APIFourierSpace","page":"Fourier Space Interface","title":"Fourier Space Interface","text":"","category":"section"},{"location":"api_reference/fourier_space/","page":"Fourier Space Interface","title":"Fourier Space Interface","text":"This module contains low level functions for operating in the frequency domain, including:","category":"page"},{"location":"api_reference/fourier_space/#ParallelKDE.FourierSpace.fourier_statistics!","page":"Fourier Space Interface","title":"ParallelKDE.FourierSpace.fourier_statistics!","text":"fourier_statistics!(device, sk, s2k, plan)\nfourier_statistics!(device, sk, plan)\n\nCalculate the Fourier transform of kernel first and second moments and its bootstrap samples.\n\ndevice specifies the device type, which can be :serial, :threaded, or :cuda. sk and s2k are the complex arrays containing the first and second moments of the kernels. plan is the FFTW plan for the Fourier transform.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/fourier_space/#ParallelKDE.FourierSpace.propagate_statistics!","page":"Fourier Space Interface","title":"ParallelKDE.FourierSpace.propagate_statistics!","text":"propagate_statistics!(device, means_t, variances_t, means_0, variances_0, time_propagated, time_initial, grid_array)\npropagate_statistics!(device, means_t, means_0, time_propagated, grid_array)\n\nPropagate the first and second moments of the kernels to larger bandwidths.\n\nArguments\n\nVal(device): Specifies the device type, which can be :serial, :threaded, or :cuda.\nmeans_t: The complex array where the propagated first moments of the kernels will be stored.\nmeans_0: The complex array containing the initial first moments of the kernels.\nvariances_t: The complex array where the propagated second moments of the kernels will be stored.\nvariances_0: The complex array containing the initial second moments of the kernels.\ntime_propagated: A vector of real numbers representing the time points at which the kernels are propagated.\ntime_initial: A vector of real numbers representing the initial time points of the kernels.\ngrid_array: An array of real numbers representing the grid points in the Fourier space.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/fourier_space/#ParallelKDE.FourierSpace.ifourier_statistics!","page":"Fourier Space Interface","title":"ParallelKDE.FourierSpace.ifourier_statistics!","text":"ifourier_statistics!(device, sk, s2k, ifft_plan)\nifourier_statistics!(device, sk, ifft_plan)\n\nCalculate the inverse Fourier transform of kernel first and second moments and its bootstrap samples.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/devices/#APIDevices","page":"Devices Interface","title":"Devices Interface","text":"","category":"section"},{"location":"api_reference/devices/","page":"Devices Interface","title":"Devices Interface","text":"The devices interface lets you specify where computations should run for a specific object.","category":"page"},{"location":"api_reference/devices/#ParallelKDE.Devices.AbstractDevice","page":"Devices Interface","title":"ParallelKDE.Devices.AbstractDevice","text":"AbstractDevice\n\nSupertype for all device types.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/#ParallelKDE.Devices.IsCPU","page":"Devices Interface","title":"ParallelKDE.Devices.IsCPU","text":"IsCPU <: AbstractDevice\n\nType representing a CPU device.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/#ParallelKDE.Devices.IsCUDA","page":"Devices Interface","title":"ParallelKDE.Devices.IsCUDA","text":"IsCUDA <: AbstractDevice\n\nType representing a CUDA-enabled GPU device.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/#ParallelKDE.Devices.DeviceNotSpecified","page":"Devices Interface","title":"ParallelKDE.Devices.DeviceNotSpecified","text":"DeviceNotSpecified <: AbstractDevice\n\nType representing a device that has not been specified or is unsupported.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/devices/","page":"Devices Interface","title":"Devices Interface","text":"Any object that is meant to run on a specific device should implement the get_device method to make use of this interface.","category":"page"},{"location":"api_reference/devices/#ParallelKDE.Devices.get_device-Tuple{Any}","page":"Devices Interface","title":"ParallelKDE.Devices.get_device","text":"get_device(device::Any)\n\nObtain the device object for a given device type.\n\nIf the method is called with an unsupported type, it returns a DeviceNotSpecified object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/devices/","page":"Devices Interface","title":"Devices Interface","text":"Additionally, a device may have one or more methods that it has available for use as well default methods when the user does not specify one. Furthermore, a Symbol may be used to identify a device type. These methods are registered in dictionaries in the Devices.jl module.","category":"page"},{"location":"api_reference/devices/#ParallelKDE.Devices.AVAILABLE_DEVICES","page":"Devices Interface","title":"ParallelKDE.Devices.AVAILABLE_DEVICES","text":"AVAILABLE_DEVICES\n\nRelate a Symbol to the corresponding device type.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/devices/#ParallelKDE.Devices.DEVICE_IMPLEMENTATIONS","page":"Devices Interface","title":"ParallelKDE.Devices.DEVICE_IMPLEMENTATIONS","text":"DEVICE_IMPLEMENTATIONS\n\nRelate the device types to their available implementations.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/devices/#ParallelKDE.Devices.DEFAULT_IMPLEMENTATIONS","page":"Devices Interface","title":"ParallelKDE.Devices.DEFAULT_IMPLEMENTATIONS","text":"DEFAULT_IMPLEMENTATIONS\n\nRelate the device types to their default implementations.\n\n\n\n\n\n","category":"constant"},{"location":"api_reference/devices/","page":"Devices Interface","title":"Devices Interface","text":"This dictionaries can be used to query the validity of a selected method for a device.","category":"page"},{"location":"api_reference/devices/#ParallelKDE.Devices.ensure_valid_implementation","page":"Devices Interface","title":"ParallelKDE.Devices.ensure_valid_implementation","text":"ensure_valid_implementation(device::AbstractDevice, implementation::Symbol)\n\nEnsure that the specified implementation is valid for the given device.\n\nIf the implementation is not valid, an ArgumentError is thrown.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/devices/","page":"Devices Interface","title":"Devices Interface","text":"Since GPU devices may work more efficiently with single-precision numbers, the package provides a method to convert double precision numbers to single precision when possible.","category":"page"},{"location":"api_reference/devices/#ParallelKDE.Devices.convert32","page":"Devices Interface","title":"ParallelKDE.Devices.convert32","text":"convert32(x)\n\nConverts into a 32-bit representation if x is a Float64, CuArray{Float64}, or Array{Float64}.\n\n\n\n\n\nconvert32(args...; kwargs...)\n\nIf multiple arguments are provided, converts each argument to a 32-bit representation if applicable, and returns a tuple of the converted arguments and a dictionary of converted keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"estimators/rot/#RotEstimator","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"","category":"section"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"The Rules of Thumb Estimator (ROT) is the estimator for calculating the bandwidth of a kernel density estimation based on rules of thumb. It is particularly useful when you want to quickly estimate the bandwidth if your underlying data is close to a Gaussian distribution.","category":"page"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"There are two currently two implemented rules of thumb:","category":"page"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"Silverman's rule [1]\nScott's rule [2]","category":"page"},{"location":"estimators/rot/#Usage","page":"Rules of Thumb Estimator","title":"Usage","text":"","category":"section"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"To use this estimator, call the estimate_density! method and pass :rot to the estimation_method argument.","category":"page"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"estimate_density!(density_estimation, :rot; kwargs...)","category":"page"},{"location":"estimators/rot/#Available-Keyword-Arguments","page":"Rules of Thumb Estimator","title":"Available Keyword Arguments","text":"","category":"section"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"method: The method to use for the estimation. Options are :serial, :threaded, or :cuda. Default is :serial for CPU and :cuda must be selected for CUDA devices.\nrule_of_thumb: The rule of thumb to use for the bandwidth estimation. Current options are :silverman or :scott. Default is :scott.","category":"page"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"warning: High dimensionality with CUDA\nImplementation with CUDA was not written to support higher dimensionality than 3D estimations.","category":"page"},{"location":"estimators/rot/#References","page":"Rules of Thumb Estimator","title":"References","text":"","category":"section"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"[1] [Silverman, B. W. (1986). Density Estimation for Statistics and Data Analysis. Chapman and Hall/CRC.]","category":"page"},{"location":"estimators/rot/","page":"Rules of Thumb Estimator","title":"Rules of Thumb Estimator","text":"[2] [Scott, D. W. (1992). Multivariate Density Estimation: Theory, Practice, and Visualization. Wiley & Sons.]","category":"page"},{"location":"estimators/gradepro/#GradeproEstimator","page":"GradePro Estimator","title":"GradePro Estimator","text":"","category":"section"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"The GradePro Estimator is the primary estimator provided by the package. It is designed to operate on dense regular grids and is optimized for parallel performance across different hardware configurations:","category":"page"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"Serial (single-threaded)\nThreaded (multi-core CPU)\nCUDA (GPU acceleration)","category":"page"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"The underlying ideas for this estimator can be found in [1]","category":"page"},{"location":"estimators/gradepro/#Usage","page":"GradePro Estimator","title":"Usage","text":"","category":"section"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"To use this estimator, call the estimate_density! method and pass :gradepro to the estimation_method argument.","category":"page"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"estimate_density!(density_estimation, :gradepro; kwargs...)","category":"page"},{"location":"estimators/gradepro/#Available-Keyword-Arguments","page":"GradePro Estimator","title":"Available Keyword Arguments","text":"","category":"section"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"method: The method to use for the estimation. Options are :serial, :threaded, or :cuda. Default is :serial for CPU and :cuda must be selected for CUDA devices.\nn_bootstraps: Number of bootstraps to use for the estimation. Default is 100.\nbw_final: Maximum bandwidth to iterate to. Default is given by Silverman's rule.\nbw_step: Size of the bandwidth step between iterations. Default is chosen for 250 iterations.\nn_steps: Number of iterations to perform. Default is 250. This has precedence over bw_step.\nalpha_s: Percentage of the total bandwidth steps of persistence beyond the thresholds before registering the crossing event. Default is 0.0 (0%) for 1D, and 0.06 (6%) for 2D.\nalpha_os: Maximum percentage of the total bandwidth steps allowed before the next estimation update before halting the estimated density updates. Default is 0.2 (20%) for 1D, and 0.1 (10%) for 2D.\neps: Threshold for convergence of low density regions. Default is 2.0 for 1D, and -0.5 for 2D.","category":"page"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"warning: Parameters for higher dimensions\nCurrently there are no tested parameters for estimations of dimensionality higher than 2D. The default in those cases is to use the 2D parameters.","category":"page"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"warning: High dimensionality with CUDA\nImplementation with CUDA was not written to support higher dimensionality than 3D estimations.","category":"page"},{"location":"estimators/gradepro/#References","page":"GradePro Estimator","title":"References","text":"","category":"section"},{"location":"estimators/gradepro/","page":"GradePro Estimator","title":"GradePro Estimator","text":"[1] [Sustay Martinez, C., Quoika P. K., Zacharias, M. (2025). Novel Rapid Approach for Adaptive Gaussian Kernel Density Estimation: Gridpoint-wise Propagation of Anisotropic Diffusion Equation]","category":"page"},{"location":"api_reference/direct_space/#APIDirectSpace","page":"Direct Space Interface","title":"Direct Space Interface","text":"","category":"section"},{"location":"api_reference/direct_space/","page":"Direct Space Interface","title":"Direct Space Interface","text":"This module contains low level functions for operating on arrays in the original (spatial) domain. These include:","category":"page"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.initialize_dirac_sequence","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.initialize_dirac_sequence","text":"initialize_dirac_sequence(data; kwargs...)\n\nCreate a Dirac sequence based on the provided data points.\n\nArguments\n\ndata: A matrix or vector of data points, where each column represents a sample.\ngrid: (optional) A grid object defining the grid on which the Dirac sequence is initialized.\nbootstrap_idxs: (optional) A matrix of indices for bootstrap resampling.\ndevice: (optional) The device type to use for computation, default is :cpu.\nmethod: (optional) The method to use for computation, default is determined by the device.\ninclude_var: (optional) If true, includes variance in the Dirac sequence, default is false.\nT: (optional) The type of the elements in the Dirac sequence, default is Float64 for CPU and Float32 for CUDA.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.calculate_scaled_vmr!","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.calculate_scaled_vmr!","text":"calculate_scaled_vmr!(\n  method::Val{device},\n  sk::AbstractArray{Complex{T},M},\n  s2k::AbstractArray{Complex{T},M},\n  time::AbstractVector{<:Real},\n  time_initial::AbstractVector{<:Real},\n  n_samples::Integer\n)\n\nCalculate the scaled variance-to-mean ratio (VMR) for an array of kernel means and kernel variances.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.calculate_full_means!","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.calculate_full_means!","text":"calculate_full_means!(method::Val{Symbol}, sk::AbstractArray{Complex{T},N}, n_samples::Integer)\n\nCalculate the means of the kernels of the full sample set.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/direct_space/#ParallelKDE.DirectSpace.identify_convergence!","page":"Direct Space Interface","title":"ParallelKDE.DirectSpace.identify_convergence!","text":"identify_convergence!\n\nIdentify the points in the grid that have converged based on the variance-to-mean ratio (VMR) and update the density accordingly.\n\nArguments\n\nVal(Symbol): The method type, e.g., :serial, :threaded, or :cuda.\ndensity: The density array to be updated.\nmeans: The means array corresponding to the density.\nvmrs_current: The current VMR values.\nvmrs_prev1: The previous VMR values.\nvmrs_prev2: The VMR values from two steps back.\ndlogt: The logarithmic time step.\ntol_low_id: The tolerance to identify low density regions.\nsteps_low: The number of steps to consider for threshold crossing to avoid effects of noise.\nsteps_over: The number of steps to consider without updates to declare convergence.\ncurrent_minima: The current minima array to be updated.\ncounters_low: The counter to identify low density regions.\ncounters_over: The counter to identify over-smoothing of high density regions.\nlow_density_flags: Flags indicating low density regions.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/estimators/#APIEstimators","page":"Estimators Interface","title":"Estimators Interface","text":"","category":"section"},{"location":"api_reference/estimators/","page":"Estimators Interface","title":"Estimators Interface","text":"This module contains the estimator definitions and dispatch infrastructure. Each estimator must implement the required interface to integrate with the current framework.","category":"page"},{"location":"api_reference/estimators/","page":"Estimators Interface","title":"Estimators Interface","text":"If you are implementing you own estimator, use this API as your reference point for compliance.","category":"page"},{"location":"api_reference/estimators/","page":"Estimators Interface","title":"Estimators Interface","text":"The supertype for all estimators is AbstractEstimator, as described below.","category":"page"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.AbstractEstimator","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.AbstractEstimator","text":"AbstractEstimator\n\nSupertype for all density estimation estimators.\n\nThis is the base for all object that are intended to provide a method for estimating the density. They store all the necessary parameters and data for the estimation process.\n\nSee also ParallelKDE.AbstractDensityEstimation for the base type where the estimated density is stored.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/estimators/","page":"Estimators Interface","title":"Estimators Interface","text":"Estimators need to be registered so that users can access them using a symbol as a name. This is done with:","category":"page"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.add_estimator!","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.add_estimator!","text":"add_estimator!(key::Symbol, value::Type{<:AbstractEstimator})\n\nInclude a new estimator type into the lookup table.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/estimators/","page":"Estimators Interface","title":"Estimators Interface","text":"The function that will be called by the User API to create an estimator is:","category":"page"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.estimate!-Tuple{Symbol, ParallelKDE.KDEs.AbstractKDE}","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.estimate!","text":"estimate!(estimator_name::Symbol, kde::AbstractKDE; kwargs...)\n\nEstimate the density of an AbstractKDE object using the specified estimator type.\n\nThe estimator_name should be a symbol that corresponds to the key in the estimator_lookup dictionary. Therefore, this is the method that the ParallelKDE.jl API uses to estimate the density.\n\nSee add_estimator! for how to add a new estimator type to the lookup table.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/estimators/","page":"Estimators Interface","title":"Estimators Interface","text":"which requires the following methods to be implemented for the estimator:","category":"page"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.initialize_estimator","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.initialize_estimator","text":"initialize_estimator(::Type{<:AbstractEstimator}, kde::AbstractKDE; kwargs...)\n\nInitialize an instance of the given estimator type with the provided KDE object and keyword arguments.\n\nEach estimator type should implement this method to set up its internal state based on the KDE data.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/estimators/#ParallelKDE.DensityEstimators.estimate!-Tuple{ParallelKDE.DensityEstimators.AbstractEstimator, ParallelKDE.KDEs.AbstractKDE}","page":"Estimators Interface","title":"ParallelKDE.DensityEstimators.estimate!","text":"estimate!(estimator_type::AbstractEstimator, kde::AbstractKDE; kwargs...)\n\nDefined this way is how each estimator type should implement the estimation process.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#APIGrids","page":"Grids Interace","title":"Grids Interace","text":"","category":"section"},{"location":"api_reference/grids/","page":"Grids Interace","title":"Grids Interace","text":"Grids define the space over which the KDE is computed. The package supports:","category":"page"},{"location":"api_reference/grids/","page":"Grids Interace","title":"Grids Interace","text":"Regular, Cartesian grids\nUser-defined bounds and resolution\nGrid selection based on data distribution","category":"page"},{"location":"api_reference/grids/","page":"Grids Interace","title":"Grids Interace","text":"There are currently two concrete grid types, one for CPU and one for CUDA devices. However, the interface is otherwise the same, so that it is possible to use the same code for both devices. It is also possible to create custom grids that conform to the interface.","category":"page"},{"location":"api_reference/grids/#ParallelKDE.Grids.AbstractGrid","page":"Grids Interace","title":"ParallelKDE.Grids.AbstractGrid","text":"AbstractGrid{N,T<:Real,M}\n\nSupertype for all grid types, where N is the number of dimensions, T is the type of the coordinates (usually Float64 or Float32), and M is the number of dimensions in the underlying array (usually N + 1).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/grids/#ParallelKDE.Grids.Grid","page":"Grids Interace","title":"ParallelKDE.Grids.Grid","text":"Grid{N,T<:Real,M}\n\nCPU object for a grid with N dimensions, T type for coordinates, and M=N+1 dimensions for the underlying array.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/grids/#ParallelKDE.Grids.CuGrid","page":"Grids Interace","title":"ParallelKDE.Grids.CuGrid","text":"CuGrid{N,T<:Real,M}\n\nCUDA object for a grid with N dimensions, T type for coordinates, and M=N+1 dimensions for the underlying array.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/grids/","page":"Grids Interace","title":"Grids Interace","text":"There is a set of features that can be extracted from grid objects. This is done by the following methods:","category":"page"},{"location":"api_reference/grids/#Base.size-Tuple{ParallelKDE.Grids.AbstractGrid}","page":"Grids Interace","title":"Base.size","text":"size(grid::AbstractGrid)\n\nReturn the size of the grid, which is a tuple containing the number of points in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#Base.ndims-Tuple{ParallelKDE.Grids.AbstractGrid}","page":"Grids Interace","title":"Base.ndims","text":"ndims(grid::AbstractGrid)\n\nReturn the number of dimensions of the grid.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#ParallelKDE.Grids.get_coordinates","page":"Grids Interace","title":"ParallelKDE.Grids.get_coordinates","text":"get_coordinates(grid::AbstractGrid)\n\nReturn a view of the coordinates of the grid as an array.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Devices.get_device-Tuple{ParallelKDE.Grids.AbstractGrid}","page":"Grids Interace","title":"ParallelKDE.Devices.get_device","text":"get_device(device::Any)\n\nObtain the device object for a given device type.\n\nIf the method is called with an unsupported type, it returns a DeviceNotSpecified object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/grids/#ParallelKDE.Grids.spacings","page":"Grids Interace","title":"ParallelKDE.Grids.spacings","text":"spacings(grid::AbstractGrid)\n\nReturn the spacings of the grid, which is a vector containing the spacing between points in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.bounds","page":"Grids Interace","title":"ParallelKDE.Grids.bounds","text":"bounds(grid::AbstractGrid)\n\nReturn the bounds of the grid, which is a 2xN matrix containing the minimum and maximum values for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.low_bounds","page":"Grids Interace","title":"ParallelKDE.Grids.low_bounds","text":"low_bounds(grid::AbstractGrid)\n\nReturn the lower bounds of the grid, which is a vector containing the minimum values for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.high_bounds","page":"Grids Interace","title":"ParallelKDE.Grids.high_bounds","text":"high_bounds(grid::AbstractGrid)\n\nReturn the upper bounds of the grid, which is a vector containing the maximum values for each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/#ParallelKDE.Grids.initial_bandwidth","page":"Grids Interace","title":"ParallelKDE.Grids.initial_bandwidth","text":"initial_bandwidth(grid::AbstractGrid)\n\nReturn the initial bandwidth for the grid, which is half of the spacings in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/","page":"Grids Interace","title":"Grids Interace","text":"It is possible to create a grid with the desired ranges with","category":"page"},{"location":"api_reference/grids/#ParallelKDE.Grids.initialize_grid","page":"Grids Interace","title":"ParallelKDE.Grids.initialize_grid","text":"initialize_grid(ranges; device=:cpu, b32=true)\ninitialize_grid(ranges...; device=:cpu, b32=true)\n\nCreate a grid object based on the provided ranges of coordinates for each dimension.\n\ndevice specifies the device type (default is :cpu but :cuda is also implemented), and, if a GPU is used, b32 determines whether to use Float32 or Float64 for the grid coordinates.\n\nExamples\n\ninitialize_grid(0.0:0.1:1.0, 0.0:0.1:1.0, device=:cuda, b32=true)\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/","page":"Grids Interace","title":"Grids Interace","text":"as well as to create a grid appropriate for the data using","category":"page"},{"location":"api_reference/grids/#ParallelKDE.Grids.find_grid","page":"Grids Interace","title":"ParallelKDE.Grids.find_grid","text":"find_grid(data; kwargs...)\n\nFind a grid based on the provided data, which can be a matrix or a vector of vectors.\n\nArguments\n\ndata: The input data, which can be an AbstractMatrix or an AbstractVector of vectors.\ngrid_bounds: Optional bounds for the grid. If not provided, bounds are calculated from the data.\ngrid_dims: Optional dimensions for the grid. If not provided, defaults to 300 points in each dimension.\ngrid_steps: Optional spacing steps for the grid to be used instead of dimensions. grid_dims takes precedence.\ngrid_padding: Optional padding for the grid bounds. If not provided, defaults to 10% of the range.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/grids/","page":"Grids Interace","title":"Grids Interace","text":"For convenience, the package includes a method to create a grid for Fourier space from a grid in direct space:","category":"page"},{"location":"api_reference/grids/#ParallelKDE.Grids.fftgrid","page":"Grids Interace","title":"ParallelKDE.Grids.fftgrid","text":"fftgrid(grid::AbstractGrid)\n\nCalculate the Fourier grid based on the spacings of the input grid. The Fourier grid contains frequencies corresponding to the grid points in each dimension.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#APIParallelKDE","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"","category":"section"},{"location":"api_reference/parallel_kde/","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"This is the main module users interact with. It re-exports the essential tools to:","category":"page"},{"location":"api_reference/parallel_kde/","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"Define and configure estimators\nRun KDEs on different devices (CPU, CUDA)\nAccess results and manipulate densities","category":"page"},{"location":"api_reference/parallel_kde/","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"Currently, the main objects for the estimation are:","category":"page"},{"location":"api_reference/parallel_kde/#ParallelKDE.AbstractDensityEstimation","page":"ParallelKDE Interface","title":"ParallelKDE.AbstractDensityEstimation","text":"AbstractDensityEstimation\n\nSupertype for all density estimation objects.\n\nThis is the base for all objects that intended to store the estimated density, and, optionally, the grid on which the density is estimated.\n\nSee also DensityEstimation for the concrete implementation.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/parallel_kde/#ParallelKDE.DensityEstimation","page":"ParallelKDE Interface","title":"ParallelKDE.DensityEstimation","text":"DensityEstimation{K<:AbstractKDE,G<:Union{Nothing,AbstractGrid}}\n\nConcrete type for density estimation objects.\n\nThis type holds a kernel density estimation (KDE) object kde and an optional grid grid.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/parallel_kde/","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"It is possible to initialize the estimation object with:","category":"page"},{"location":"api_reference/parallel_kde/#ParallelKDE.initialize_estimation","page":"ParallelKDE Interface","title":"ParallelKDE.initialize_estimation","text":"initialize_estimation(data; kwargs...)\n\nInitialize a density estimation object based on the provided data.\n\nArguments\n\ndata::Union{AbstractMatrix,AbstractVector{<:AbstractVector}}: The data to be used for density estimation.\ngrid::Union{Bool,G<:AbstractGrid}=false: Whether to create a grid for the density estimation.\n\nIf true, a grid will be created based on the data ranges. A grid can also be provided directly.\n\ngrid_ranges=nothing: The ranges for the grid coordinates if grid is true.\n\nThis has priority over other grid parameters.\n\ndims=nothing: The dimensions of the grid if grid is true.\ngrid_bounds=nothing: The bounds for the grid if grid is true.\ngrid_padding=nothing: Padding for the grid if grid is true.\ndevice=:cpu: The device to use for the density estimation. It should be compatible with the estimator to be used.\n\nExamples\n\ndata = randn(1, 1000);\ndensity_estimation = initialize_estimation(data; grid=true, grid_ranges=-5.0:0.1:5.0, device=:cpu);\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"Estimation objects are designed to support a grid for grid-based density estimation. However, this is not mandatory. To test if a grid is present and obtain a grid object, you can use:","category":"page"},{"location":"api_reference/parallel_kde/#ParallelKDE.has_grid","page":"ParallelKDE Interface","title":"ParallelKDE.has_grid","text":"has_grid(density_estimation::DensityEstimation)\n\nReturn true if the DensityEstimation object has a grid associated with it, false otherwise.\n\nExamples\n\ndata = randn(1, 1000);\ndensity_estimation = initialize_estimation(data; grid=true, grid_ranges=-5.0:0.1:5.0, device=:cpu);\nhas_grid(density_estimation)\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#ParallelKDE.get_grid","page":"ParallelKDE Interface","title":"ParallelKDE.get_grid","text":"get_grid(density_estimation::DensityEstimation)\n\nExtract the grid from a DensityEstimation object.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/","page":"ParallelKDE Interface","title":"ParallelKDE Interface","text":"Executing the estimation and obtaining the density is done with:","category":"page"},{"location":"api_reference/parallel_kde/#ParallelKDE.estimate_density!","page":"ParallelKDE Interface","title":"ParallelKDE.estimate_density!","text":"estimate_density!(density_estimation::DensityEstimation, estimation_method::Symbol; kwargs...)\n\nEstimate the density using the specified method and update the DensityEstimation object.\n\nFor a list of available estimation methods and their keywords, see the documentation for the specific estimator.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/parallel_kde/#ParallelKDE.KDEs.get_density-Tuple{DensityEstimation}","page":"ParallelKDE Interface","title":"ParallelKDE.KDEs.get_density","text":"get_density(density_estimation::DensityEstimation; normalize=false, dx=nothing)\n\nObtain the estimated density from a DensityEstimation object.\n\nIf the normalize argument is set to true, the density will be normalized. If density_estimation has a grid, its spacing will be used for normalization. Otherwise, dx must be provided to normalize the density.\n\n\n\n\n\n","category":"method"},{"location":"#ParallelKDE","page":"Home","title":"ParallelKDE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ParallelKDE is a package for flexible and efficient kernel density estimation (KDE), with a strong focus on parallel implementations. Its core estimator, the Parallel Estimator described here, supports CPU and GPU acceleration (threaded and CUDA), and its designed to scale with modern hardware. While the package is centered around grid-based KDEs, it also provides extensible infrastructure to support and implement other types of estimators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The user interface is built around a modular design that separates concerns between grids, devices, density objects and estimation routines. This allows users to easily switch estimators, control execution targets (e.g., CPU or GPU), and prototype new estimation strategies without rewriting boilerplate code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Typical usage involves:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instantiating an estimation in a specific device (e.g., CPU, CUDA),\nThis also involves defining a grid for the estimation or using a default grid,\nEstimating the density with a chosen estimator,\nAccessing the resulting density.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, to estimate a density on a CPU with a default grid using the GradePro Estimator, you can use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ParallelKDE\n\ndata = randn(1, 10000) # 1-dimensional sample of 10000 points\n\ndensity_estimation = initialize_estimation(\n  data,\n  grid=true,\n  device=:cpu,\n)\nestimate_density!(\n  density_estimation,\n  :gradepro,\n)\n\ndensity_estimated = get_density(density_estimation)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can evaluate the standard normal distribution for comparison:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Distributions\n\ngrid_coordinates = get_coordinates(get_grid(density_estimation))[1, :]\ndensity_true = pdf.(Normal(), grid_coordinates)\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"which would yield a plot like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots # hide\np = plot(grid_coordinates, density_true, label=\"True Density\", color=:cornflowerblue, lw=2)\nplot!(p, grid_coordinates, density_estimated, label=\"Estimated Density\", color=:firebrick, lw=2)\nplot!(p, xlabel=\"Random Variable\", ylabel=\"Density\")\nsavefig(\"basic_usage.svg\"); nothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"As it is exemplified above, it is possible to initialize an estimation using","category":"page"},{"location":"#ParallelKDE.initialize_estimation-index","page":"Home","title":"ParallelKDE.initialize_estimation","text":"initialize_estimation(data; kwargs...)\n\nInitialize a density estimation object based on the provided data.\n\nArguments\n\ndata::Union{AbstractMatrix,AbstractVector{<:AbstractVector}}: The data to be used for density estimation.\ngrid::Union{Bool,G<:AbstractGrid}=false: Whether to create a grid for the density estimation.\n\nIf true, a grid will be created based on the data ranges. A grid can also be provided directly.\n\ngrid_ranges=nothing: The ranges for the grid coordinates if grid is true.\n\nThis has priority over other grid parameters.\n\ndims=nothing: The dimensions of the grid if grid is true.\ngrid_bounds=nothing: The bounds for the grid if grid is true.\ngrid_padding=nothing: Padding for the grid if grid is true.\ndevice=:cpu: The device to use for the density estimation. It should be compatible with the estimator to be used.\n\nExamples\n\ndata = randn(1, 1000);\ndensity_estimation = initialize_estimation(data; grid=true, grid_ranges=-5.0:0.1:5.0, device=:cpu);\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Then, the density can be estimated with a chosen estimator and its settings using","category":"page"},{"location":"#ParallelKDE.estimate_density!-index","page":"Home","title":"ParallelKDE.estimate_density!","text":"estimate_density!(density_estimation::DensityEstimation, estimation_method::Symbol; kwargs...)\n\nEstimate the density using the specified method and update the DensityEstimation object.\n\nFor a list of available estimation methods and their keywords, see the documentation for the specific estimator.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Finally, the estimated density can be accessed using","category":"page"},{"location":"#ParallelKDE.KDEs.get_density-Tuple{DensityEstimation}-index","page":"Home","title":"ParallelKDE.KDEs.get_density","text":"get_density(density_estimation::DensityEstimation; normalize=false, dx=nothing)\n\nObtain the estimated density from a DensityEstimation object.\n\nIf the normalize argument is set to true, the density will be normalized. If density_estimation has a grid, its spacing will be used for normalization. Otherwise, dx must be provided to normalize the density.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"More details regarding the currently implemented estimators as well as further information about the package can be found throughout the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
